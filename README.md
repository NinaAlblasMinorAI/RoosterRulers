# Rooster Rulers' Project: the Perfect Schedule

## Introduction
In this case, a week schedule is created for a list of courses on UvA Science Park.
- Courses consist of lectures and/or tutorials and/or labs. There is a maximum number of students defined for each tutorial and lab.
- There are seven rooms of varying capacities, and each room is suited to host lectures, tutorials, as well as labs.
- All lectures, tutorials, and labs need to be placed in a time slot. The available time slots are 09:00-11:00, 11:00-13:00, 13:00-15:00, and 15:00-17:00, from Monday to Friday. The largest room (C0.110) also has an evening slot (17:00-19:00). This makes for a total of 145 available room-time slots.
- A week schedule is valid when all lectures, tutorials, and labs (i.e., "lessons") are assigned a room-time slot and no students have 3 adjacent free periods between lessons.
- A room-time slot can only be used for one lesson at a time.
- Each student has an individual schedule with x number of registered courses.

The goal of this case is to create a schedule that optimizes the number of students that fit into the rooms of their lessons. Additionally it is wished to minimize the number of used evening slots, and the lesson conflicts and free periods of the students' individual schedules. Because not complying to any of these constraints will increase our objective value, the goal is to minimize this, with a theoretical minimum of 0.

Factors that increase the objective value:
- Exceding room capacity: 1 point per excess student
- Use of evening slots: 5 points per lesson
- Lesson conflicts: 1 point per lesson conflict of student
- Free periods: 1 point for 1 free period in between lessons of student, 3 points for 2 periods

&nbsp;  

## Getting Started

### Prerequisites

This codebase was completely written in [Python3.8.10](https://www.python.org/downloads/). In requirements.txt the user can find all the required packages to succesfully run the code. These are easily installed through pip using the following command:

```
pip install -r requirements.txt
```

### Structure

The files are divided into the following folders:
- `/code`: all Python scripts, including the following subfolders:
    - `/algorithms`
    - `/classes`
    - `/trash` (obsolete code)
    - `/visualization`

- `/doc`: documents (e.g. presentations)
- `/input_data`: the input data of the case (e.g. the .csv file with the list of courses)
- `/output_data`: the output data generated by the scripts (with example output)


### Running

Use the command below to run the code. For distributing the lessons over the schedule, the user can choose from the 'random', 'hillclimber', and 'simulated_annealing' algorithm. For distributing the students over the lessons, the 'hillclimber' algorithm is always used, so this does not need to be specified. For redistributing the courses into additional tutorials or labs, the "greedy" algorithm is always used, so this also does not need to be given as a command-line argument.

```
python main.py <algorithm> 
```

Following command line arguments are available:
- -n -> number of total runs (number of schedules that are made)
- -O -> number of optimize runs splitting off additional lessons
- -c -> number of additional lessons to create per optimize run
- -r -> number of repeats for redistributing lessons; for 'hillclimber', it is the number of iterations that the objective value does not change before the algorithm stops, for 'simulated annealing', it is the total number of iterations.
- -o -> number of outer repeats for redistributing students; the number of iterations that a course is selected from which all tutorials or labs are shuffled and the objective value does not change before the algorithm stops 
- -i -> number of inner repeats for redistributing students; the number of iterations that two students are selected and the objective value does not change before the algorithm stops
- -t -> starting temperature for 'simulated annealing'
- -v -> verbose; boolean that indicates extra logging on the command prompt


Use the command below to print the malus points and to generate a csv output and a Bokeh schedule from an existing pickle file containing a schedule 

```
python load_pickle.py <pickle file name in /output_data> 
```

## Output files
The following files are generated for each execution of main.py with the  hillclimber or simulated annealing algorithm in folder `/output_data`:
- A log file with the intermediate and final results of each run.
- A line plot of the iterations (x-axis) and objective value (y-axis)
- A pickle file of the best schedule 
- A bokeh output of the best schedule 
- A CSV output of the schedule of all students of the best schedule
- A box_plot of the results of each run

## Algorithms
The algorithms below were used. The sequence of performed acts to improve the schedule are as follows: first lessons are redistributed, then students are redistributed, and then additional lessons are generated. This proces can be repeated a number of times. In the last optimization run, no additonal lessons are generated.
- random -> the random algoritm is used for generating a base schedule that can be optimized. The minimal number of lessons are created (129) by taking into account the maximum number of students per lesson (for labs and tutorials). Students are then evenly distributed over these lessons (e.g., a course with 36 students and 15 max students per lab has 3 labs with 12 students). Constraint relaxation is applied to the hard constraint that 3 free periods between 2 lessons is not allowed. Instead 100 malus points are assigned for each of these violations. 
- hillclimber -> the hillclimber algorithm is used for redistributing the lessons over the schedule and for redistributing the students over the lessons. 
    - hillclimber for lessons -> when redistributing the lessons over the schedule, the contents of two random locations are swapped. These locations can be either lessons or empty slots. If the swap leads to less malus points, the change is retained, otherwise the change is reversed. If the score is not improved for a specified number of runs, the algorithm stops.
    - hillclimber for students -> the hillclimber for redistributing students randomly picks all tutorials or labs of a course. After that, it randomly selects two of those lessons and of those, two slots in which students can be present. These slots either contain a student or are empty. The contents of these slots are swapped. If the swap leads to less malus points, the change is retained, otherwise the change is reversed. If the malus points do not decrease after a specified number of iterations of student swapping between the lessons of one course, this part stops of the algorithm stops, and all tutorials or labs of another randomly selected course are grabbed. If choosing all lessons of a random course does not improve for a specified number of iterations, the entire algorithm stops.
- simulated annealing for lessons -> the simulated annealing algorithm is used for redistributing lessons. As described in the hillclimber algorithm of redistributing lessons, the contents of two random positions in the schedule are swapped. However, there now is a chance of exepting the change (even when it leads to a worse result) and is calculated with the following function: `chance = 2 * (old objective value â€“ new objective value) / temperature`. 
With each iteration the temperature decreases linearly. That means that in the beginning of the run, more increases in malus points are retained than in the end. 
- greedy algorithm -> for creating additional lessons, a greedy algorithm is used. X number of additional lessons are created by choosing the X courses with the highest objective value and then taking from each of these courses the tutorial or lab with again the highest objective value. For these tutorials and labs, an additional lesson is created and students are divided evenly over the two.
       
## Authors

* Nina Alblas
* Marc Jurriens
* Dennis Vlegels


## Acknowledgments

Many thanks to Mayla Kersten and Quinten van der Post for the amazing guidance during this project.